/*********************************************
Project : Test software          
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>
#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include "defs.h"  
#include <alcd.h>
//#include <alcd_ks0073.h>  

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

/*
 * Timer 1 Output Compare A interrupt is used to blink LED
 */
//interrupt [TIM1_COMPA] void timer1_compa_isr(void)
//{
//LED1 = ~LED1; // invert LED    
//}                                  

/*
 * main function of program
 */                                  
 
void main (void)
{          
// acesta 5 variabile de mai jos sunt fanioane pentru switch-uri
unsigned char ip = 0;       //B1
unsigned char new = 0;      //B2
unsigned char start = 0;    //B3
unsigned char probe = 0;    //B4
unsigned char led = 0;      //SW1 - adica USR SWITCH

	Init_initController();  // this must be the first "init" action/call!
	#asm("sei")             // enable interrupts
	LED1 = 1;           	// initial state, will be changed by timer 1
    lcd_init(20);
    
	while(TRUE)
	{
		wdogtrig();	        // call often else processor will reset                
        if(ip == 0 && start == 0)
        {    
            lcd_gotoxy(0,0); 
            lcd_puts("Detector retele WiFi");
            lcd_gotoxy(0,1);
            lcd_puts("                    ");   
            lcd_gotoxy(0,2); 
            lcd_puts("B1-IP&MAC|B2-return ");
            lcd_gotoxy(0,3); 
            lcd_puts("B3-Nr.Dvc|B4-testESP"); 
        }   
                 
        if(SW1 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(SW1 == 0)    
            {                // LED will blink slow or fast
                while(SW1==0) wdogtrig();  
                led = 1;
            }                
        }
        
        if(B1 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(B1 == 0)    
            {                // LED will blink slow or fast
                while(B1==0) wdogtrig();  
                ip = 1;
            }                
        }
         
        if(B2 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(B2 == 0)    
            {                // LED will blink slow or fast
                while(B2==0) wdogtrig();  
                new = 1;   
            }                
        }    
        
        if(B3 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(B3 == 0)    
            {                // LED will blink slow or fast
                while(B3==0) wdogtrig();  
                start = 1;    
            }                
        } 
        
        if(B4 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(B4 == 0)    
            {                // LED will blink slow or fast
                while(B4==0) wdogtrig();  
                probe = 1;
            }                
        } 
        
        if(led == 1)
            {
                LED1 = 0;
                delay_ms(1000); //e cam mult, dar se apasa rar
                led = 0;
            } 
        
        if(ip == 1 && start == 0)
        {   
            unsigned char i = 0;
            char response[64], instruction[] = "AT+CIFSR\r\n"; //Gets the Local IP Address
            lcd_gotoxy(0,0);
            lcd_puts("IP address of ESP:  ");  
            lcd_gotoxy(0,1);
            lcd_puts("IP:");  
            lcd_gotoxy(0,2);
            lcd_puts("MC:");
            lcd_gotoxy(0,3);
            lcd_puts("                    "); // spatii libere ca sa nu se suprapuna afisajele
                      
                
                while(instruction[i] != NULL)
		    	{
		    		putchar(instruction[i]);
		    		++i;
		    	}	
			    i = 0;          
                                         
                while(rx_counter0)   
                {      
                    response[i] = getchar(); // l-am luat separat daca e nevoie de prelucrari
		    	    ++i;
                }  
                i = 0;
                while(response[i] != NULL)
                {
                    lcd_gotoxy(i+2,1);
                    lcd_putchar(response[i]);
                    //lcd_gotoxy(i+2,2); respectiv, dar asta dupa prelucrarea lui response
                    ++i;
                }   
                //Ex: 
                lcd_gotoxy(3,1);
                lcd_puts("192.168.100.1    "); 
                lcd_gotoxy(3,2);
                lcd_puts("00:00:00:a1:2b:cc");
                
            }   
                                   
            if(start == 1 && ip == 0)  
            {  
                unsigned char i = 0, nr = 0;
                char number;
                char response[128];
                char instruction1[] = "AT+CWMODE_DEF=2\r";//sets esp as AP with configuration saved in the flash
                char instruction2[] = "AT+CWLIF\r\n";  // get IP and MAC addresses of stations connected to it 
                lcd_gotoxy(0,0);
                lcd_puts("Nr unique devices:");
                lcd_gotoxy(0,1);
                lcd_puts("The first device is:");
                lcd_gotoxy(0,2);
                lcd_puts("IP:");
                lcd_gotoxy(0,3);                     
                lcd_puts("MC:");      
                
                while(instruction1[i] != NULL)
		    	{
		    		putchar(instruction1[i]);
		    		++i;
		    	}	
                wdogtrig();    
                i=0;  
                while(instruction2[i] != NULL)
		    	{
		    		putchar(instruction2[i]);
		    		++i;
		    	}
                wdogtrig();	 
			    i = 0;                          
                while(rx_counter0)   
                {      
                    response[i] = getchar();  //l-am luat separat daca e nevoie de prelucrari
			        ++i;
                    if(response[i] == 'O' && response[i+1] == 'K') ++nr;
                }  
//*************************************************************************************************
// Acest cod este comentat deoarece are sens doar pentru o functionare reala a modulului ESP; in simulare nu avea rost sa ruleze     
//              i = 0;
//                          
//                while(i < 13) //ca IP-ul are 13 cifre
//                {  
//                    lcd_gotoxy(3,2);
//                    lcd_putchar(response[i]);
//                    ++i;
//                }    
//                
//                while(i < 30) ca MAC-ul are 17 cifre hex si 'i' a ramas 12
//                {
//                    lcd_gotoxy(3,3);
//                    lcd_putchar(response[i]);
//                    ++i;
//                }          
//*************************************************************************************************              
                lcd_gotoxy(13,1);
                lcd_putchar(nr);       
                 
                //Ex:   
                nr = 18;
                if(nr > 9){
                number = (char)(nr/10+48);lcd_gotoxy(18,0); lcd_putchar(number);number = (char)(nr%10+48);lcd_gotoxy(19,0);lcd_putchar(number); //vezi cod ASCII
                }
                if(nr <= 9){
                number = (char)(nr+48); lcd_gotoxy(18,0);lcd_putchar(' ');lcd_gotoxy(19,0);lcd_putchar(number); //vezi cod ASCII
                }
                lcd_gotoxy(3,2);
                lcd_puts("192.168.100.1    "); 
                lcd_gotoxy(3,3);
                lcd_puts("00:00:00:a1:2b:cc");               
            }  
            
            if(probe == 1 && ip == 0 && start == 0)
            {          
                unsigned char i = 0;
                char response[64], instruction[] = "AT\r\n";
                while(instruction[i] != NULL)
			    {
				    putchar(instruction[i]);
				    ++i;
			    }	
			    i = 0;          
                                         
                while(rx_counter0)   
                {      
                    response[i] = getchar(); // l-am luat separat daca e nevoie de prelucrari
			        ++i;
                }  
                i = 0;
                while(response[i] != NULL)
                {
                    lcd_gotoxy(0,3);
                    lcd_putchar(response[i]);
                    ++i;
                } 
                //Ex:  
                lcd_gotoxy(0,1);
                lcd_puts("OK");
                delay_ms(1000);
                probe = 0;
            }  
                                             
            if(new ==  1)  
            {   
                unsigned char i = 0;
                char instruction[] = "AT+RST\r\n";     // si restarteaza esp        
                ip = 0;
                start = 0;
                new = 0;                  
                
                while(instruction[i] != NULL)
			    {
				    putchar(instruction[i]);
				    ++i;
			    }         
            }     
    }                               
}// end main loop 


